<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tetris</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
        font-family: Arial, sans-serif;
      }
      canvas {
        border: 2px solid #333;
        background-color: #111;
      }
      .game-container {
        display: flex;
        gap: 20px;
      }
      .info-panel {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .next-piece {
        width: 100px;
        height: 100px;
        border: 2px solid #333;
        background-color: #222;
      }
      .score-board {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .score-item {
        padding: 5px;
        background-color: #333;
        color: white;
        border-radius: 5px;
        text-align: center;
      }
      .controls {
        margin-top: 20px;
        text-align: center;
        padding: 10px;
        background-color: #333;
        color: white;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <h1>Tetris</h1>
    <div class="game-container">
      <canvas id="tetris" width="300" height="600"></canvas>
      <div class="info-panel">
        <div>
          <h3>Next Piece</h3>
          <canvas id="nextPiece" width="100" height="100"></canvas>
        </div>
        <div class="score-board">
          <h3>Score</h3>
          <div id="score" class="score-item">0</div>
          <h3>Lines</h3>
          <div id="lines" class="score-item">0</div>
          <h3>Level</h3>
          <div id="level" class="score-item">1</div>
        </div>
      </div>
    </div>
    <div class="controls">
      <p>
        Controls: Arrow Left/Right - Move, Arrow Up - Rotate, Arrow Down - Soft
        Drop, Space - Hard Drop
      </p>
    </div>

    <script>
      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d');
      const nextPieceCanvas = document.getElementById('nextPiece');
      const nextPieceCtx = nextPieceCanvas.getContext('2d');

      // Game constants
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = canvas.width / COLS;
      const NEXT_BLOCK_SIZE = 25;

      // Tetromino colors
      const COLORS = [
        null,
        '#FF0D72', // I
        '#0DC2FF', // O
        '#0DFF72', // T
        '#F538FF', // S
        '#FF8E0D', // Z
        '#FFE138', // J
        '#3877FF', // L
      ];

      // Tetromino shapes
      const SHAPES = [
        [],
        // I
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0],
        ],
        // O
        [
          [2, 2],
          [2, 2],
        ],
        // T
        [
          [0, 3, 0],
          [3, 3, 3],
          [0, 0, 0],
        ],
        // S
        [
          [0, 4, 4],
          [4, 4, 0],
          [0, 0, 0],
        ],
        // Z
        [
          [5, 5, 0],
          [0, 5, 5],
          [0, 0, 0],
        ],
        // J
        [
          [6, 0, 0],
          [6, 6, 6],
          [0, 0, 0],
        ],
        // L
        [
          [0, 0, 7],
          [7, 7, 7],
          [0, 0, 0],
        ],
      ];

      // Game state
      let grid = createGrid();
      let score = 0;
      let lines = 0;
      let level = 1;
      let gameOver = false;
      let dropCounter = 0;
      let dropInterval = 1000; // Initial drop speed in ms
      let lastTime = 0;
      let player = {
        pos: { x: 0, y: 0 },
        matrix: null,
        next: null,
      };

      // Initialize the game
      initGame();

      function initGame() {
        updateScore(0);
        updateLines(0);
        updateLevel(1);
        grid = createGrid();
        generatePiece();
        update();
      }

      function createGrid() {
        return Array.from(Array(ROWS), () => Array(COLS).fill(0));
      }

      function drawGrid() {
        // Draw the background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw the grid lines
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;

        // Vertical lines
        for (let i = 1; i < COLS; i++) {
          ctx.beginPath();
          ctx.moveTo(i * BLOCK_SIZE, 0);
          ctx.lineTo(i * BLOCK_SIZE, canvas.height);
          ctx.stroke();
        }

        // Horizontal lines
        for (let i = 1; i < ROWS; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * BLOCK_SIZE);
          ctx.lineTo(canvas.width, i * BLOCK_SIZE);
          ctx.stroke();
        }

        // Draw the placed pieces
        for (let y = 0; y < ROWS; y++) {
          for (let x = 0; x < COLS; x++) {
            if (grid[y][x]) {
              drawBlock(ctx, x, y, grid[y][x], BLOCK_SIZE);
            }
          }
        }

        // Draw the active piece
        if (player.matrix) {
          drawMatrix(ctx, player.matrix, player.pos, BLOCK_SIZE);
        }
      }

      function drawBlock(context, x, y, color, size) {
        context.fillStyle = COLORS[color];
        context.fillRect(x * size, y * size, size, size);
        context.strokeStyle = '#000';
        context.strokeRect(x * size, y * size, size, size);

        // Add a shine effect
        context.fillStyle = 'rgba(255, 255, 255, 0.1)';
        context.fillRect(x * size, y * size, size / 2, size / 2);
      }

      function drawMatrix(context, matrix, offset, size) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              drawBlock(context, x + offset.x, y + offset.y, value, size);
            }
          });
        });
      }

      function drawNextPiece() {
        // Clear the next piece canvas
        nextPieceCtx.fillStyle = '#222';
        nextPieceCtx.fillRect(
          0,
          0,
          nextPieceCanvas.width,
          nextPieceCanvas.height,
        );

        if (player.next) {
          // Calculate centering offsets
          const width = player.next[0].length;
          const height = player.next.length;

          const offsetX = (nextPieceCanvas.width / NEXT_BLOCK_SIZE - width) / 2;
          const offsetY =
            (nextPieceCanvas.height / NEXT_BLOCK_SIZE - height) / 2;

          drawMatrix(
            nextPieceCtx,
            player.next,
            { x: offsetX, y: offsetY },
            NEXT_BLOCK_SIZE,
          );
        }
      }

      function generatePiece() {
        // If we have a next piece, use it
        if (player.next) {
          player.matrix = player.next;
        } else {
          // First piece
          const pieceType = Math.floor(Math.random() * 7) + 1;
          player.matrix = SHAPES[pieceType];
        }

        // Generate the next piece
        const nextPieceType = Math.floor(Math.random() * 7) + 1;
        player.next = SHAPES[nextPieceType];

        // Reset position
        player.pos.y = 0;
        player.pos.x =
          Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);

        // Game over check
        if (checkCollision()) {
          gameOver = true;
          alert('Game Over! Your score: ' + score);
          initGame();
        }

        drawNextPiece();
      }

      function rotate(matrix) {
        const N = matrix.length;
        const result = Array.from(Array(N), () => Array(N).fill(0));

        // Transpose
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            result[j][i] = matrix[i][j];
          }
        }

        // Reverse each row
        for (let i = 0; i < N; i++) {
          result[i].reverse();
        }

        return result;
      }

      function playerRotate() {
        const originalPos = player.pos.x;
        let offset = 1;
        const rotated = rotate(player.matrix);
        player.matrix = rotated;

        // Handle collision after rotation
        while (checkCollision()) {
          player.pos.x += offset;
          offset = -(offset + (offset > 0 ? 1 : -1));

          // If offset is too large, rotation isn't possible
          if (offset > player.matrix[0].length) {
            player.matrix = SHAPES[player.matrix[0][0]]; // Revert to original shape
            player.pos.x = originalPos;
            return;
          }
        }
      }

      function playerMove(dir) {
        player.pos.x += dir;
        if (checkCollision()) {
          player.pos.x -= dir;
        }
      }

      function playerDrop() {
        player.pos.y++;
        if (checkCollision()) {
          player.pos.y--;
          merge();
          checkLines();
          generatePiece();
        }
        dropCounter = 0;
      }

      function playerHardDrop() {
        while (!checkCollision()) {
          player.pos.y++;
        }
        player.pos.y--;
        merge();
        checkLines();
        generatePiece();
        dropCounter = 0;
      }

      function checkCollision() {
        const matrix = player.matrix;
        const pos = player.pos;

        for (let y = 0; y < matrix.length; y++) {
          for (let x = 0; x < matrix[y].length; x++) {
            if (
              matrix[y][x] !== 0 &&
              (grid[y + pos.y] === undefined ||
                grid[y + pos.y][x + pos.x] === undefined ||
                grid[y + pos.y][x + pos.x] !== 0)
            ) {
              return true;
            }
          }
        }

        return false;
      }

      function merge() {
        player.matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              grid[y + player.pos.y][x + player.pos.x] = value;
            }
          });
        });
      }

      function checkLines() {
        let linesCleared = 0;

        rowLoop: for (let y = ROWS - 1; y >= 0; y--) {
          for (let x = 0; x < COLS; x++) {
            if (grid[y][x] === 0) {
              continue rowLoop;
            }
          }

          // This row is full, clear it
          const row = grid.splice(y, 1)[0].fill(0);
          grid.unshift(row);
          y++;
          linesCleared++;
        }

        if (linesCleared > 0) {
          // Update score - more points for clearing multiple lines at once
          const points = [0, 40, 100, 300, 1200][linesCleared] * level;
          updateScore(score + points);
          updateLines(lines + linesCleared);

          // Update level every 10 lines
          const newLevel = Math.floor(lines / 10) + 1;
          if (newLevel > level) {
            updateLevel(newLevel);
            // Increase speed
            dropInterval = 1000 - (level - 1) * 50;
            // Cap the speed at a reasonable level
            if (dropInterval < 100) {
              dropInterval = 100;
            }
          }
        }
      }

      function updateScore(newScore) {
        score = newScore;
        document.getElementById('score').textContent = score;
      }

      function updateLines(newLines) {
        lines = newLines;
        document.getElementById('lines').textContent = lines;
      }

      function updateLevel(newLevel) {
        level = newLevel;
        document.getElementById('level').textContent = level;
      }

      function update(time = 0) {
        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
          playerDrop();
        }

        drawGrid();
        requestAnimationFrame(update);
      }

      // Event listeners
      document.addEventListener('keydown', (e) => {
        if (!gameOver) {
          if (e.key === 'ArrowLeft') {
            playerMove(-1);
          } else if (e.key === 'ArrowRight') {
            playerMove(1);
          } else if (e.key === 'ArrowDown') {
            playerDrop();
          } else if (e.key === 'ArrowUp') {
            playerRotate();
          } else if (e.key === ' ') {
            playerHardDrop();
          }
        }
      });
    </script>
  </body>
</html>
